package parser ;
import tables.SymbolTable;
import tables.SymbolInfo;
import tables.FunctionInfo;
import tables.TokenInfo;
import semanticalAnalysis.Variable;
import semanticalAnalysis.Function;
import semanticalAnalysis.ControlStructureOperations;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java_cup.runtime.*;

//utiliza class Lexer que genera el lexer.jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:

action code {:
    /*CODIGO DE JAVA
    https://www.jflex.de/
    http://www2.cs.tum.edu/projects/cup/examples.php*/

    public void hola(){

                System.out.println("Hola");
    }

    public void adios(){

                System.out.println("Adiós");
    }
:}

parser code {:
    Lexer parser;
    SymbolTable symbolTable = new SymbolTable();

    // Constructor del parser
    @SuppressWarnings("deprecation")
    public parser(Lexer parser){
        this.parser = parser;
        this.symbolFactory = new DefaultSymbolFactory();

        // Inicializar el ámbito global
        FunctionInfo globalFunction = new FunctionInfo("global", "void",0,0, new ArrayList<>());
        if (!symbolTable.pushFunction(globalFunction)) {
            System.err.println("Error: Función global ya está definida.");
        }
        globalFunction.beginScope();
    }

    @Override
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error sintactico, linea: " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error sintactico: " + message);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        // Reportar el error fatal sin detener el programa
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error fatal sintactico " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error fatal de sintaxis: " + message);
        }
    }

    @Override
    public void unrecovered_syntax_error(Symbol info) {
        if (info.value != null) {
            System.err.println("Error no recuperable en la linea " + (info.left + 1) + ", columna " + (info.right + 1));
        }
    }
:}

init with {: :};

/* define how to connect to the scanner! */
scan with {: return parser.next_token(); :};


/* Terminales (tokens retornados por el scanner). */
terminal BOOLEAN, BREAK, IDENTIFIER, INTEGER, INTEGER_LITERAL, STRING, EQ, EQEQ, PLUS, STRING_LITERAL,
 FLOAT, CHAR, OPEN_BLOCK, CLOSE_BLOCK, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN,
 MINUS, TIMES, DIV, MOD, POW, INCREMENT, DECREMENT, NEQ, LT, LE, GT, GE, AND, OR, NOT, SEMICOLON,
 IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, RETURN, COLON, PRINT, READ, MAIN, COMMA, CHAR_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, TokenInfo;

// no terminales
non terminal programa, tipos, sentencias, sentencia, creacion, creacionAsignacion, nombrar,
 literales, funciones, funcion, bloque, encabezadoFuncion, parametros, parametroAux, parametro,
 estructuraControl, if_stmt, else_if_list, else_if_list_opt, while_cicle, switch_stmt, for_cicle, return_stmt, break_stmt, expresion,
 expresion_aritmetica, literales_num, unary_operators, negacion, case_list, arreglo,
 listaValores, case_stmt, default_stmt, conjuntoFunciones, funcionMain, bloque_switch, default_stmt_opt, expresion_logica,
 expresion_comparacion, condicion_for, inicializacion_opt, condicion_opt, actualizacion_opt, print_stmt, lista_print, read_stmt,
 apertura_bloque, cierre_bloque, asignar, array_size, llamada_funcion, argumentos;


// Precedencias

precedence left ELSE;

precedence left EQEQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left AND, OR;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left POW;

//produccion de inicio
start with programa;

// Generalidades
tipos ::= INTEGER {: RESULT = "int"; :}
       | STRING  {: RESULT = "string"; :}
       | CHAR    {: RESULT = "char"; :}
       | BOOLEAN {: RESULT = "boolean"; :}
       | FLOAT   {: RESULT = "float"; :}
       ;

literales ::= INTEGER_LITERAL:i
{:
    TokenInfo token = (TokenInfo) i;
    RESULT = new SymbolInfo("int", "int", token.getLine() + 1, token.getColumn() + 1);
:}
| STRING_LITERAL:s
{:
    TokenInfo token = (TokenInfo) s;
    RESULT = new SymbolInfo("string", "string", token.getLine() + 1, token.getColumn() + 1);
:}
| CHAR_LITERAL:c
{:
    TokenInfo token = (TokenInfo) c;
    RESULT = new SymbolInfo("char", "char", token.getLine() + 1, token.getColumn() + 1);
:}
| BOOLEAN_LITERAL:b
{:
    TokenInfo token = (TokenInfo) b;
    RESULT = new SymbolInfo("boolean", "boolean", token.getLine() + 1, token.getColumn() + 1);
:}
| FLOAT_LITERAL:f
{:
    TokenInfo token = (TokenInfo) f;
    RESULT = new SymbolInfo("float", "float", token.getLine() + 1, token.getColumn() + 1);
:}
;

// Literales Numéricos
literales_num ::= INTEGER_LITERAL | FLOAT_LITERAL | CHAR_LITERAL ;

nombrar ::= tipos:t IDENTIFIER:id
{:
    // Obtener el tipo
    String tipo = (String) t;

    // Cast correcto de 'id' a TokenInfo
    TokenInfo token = (TokenInfo) id;

    // Obtener el nombre, línea y columna
    String nombre = token.getValue();
    int linea = token.getLine() + 1;
    int columna = token.getColumn() + 1;

    // Imprimir la información de declaración
    //System.out.println("Declaración de variable '" + nombre + "' de tipo '" + tipo + "' en línea " + linea + ", columna " + columna);

    // Crear el SymbolInfo con la información de posición
    RESULT = new SymbolInfo(nombre, tipo, linea, columna);
:};

// Expresiones
expresion ::= expresion_logica:el {: RESULT = el; :} ;

expresion_logica ::= expresion_logica AND expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | expresion_logica OR expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | NOT expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | expresion_comparacion:ec
                   {:
                       RESULT = ec;
                   :};

expresion_comparacion ::= expresion_aritmetica:ea1 EQEQ expresion_aritmetica:ea2
                       {:
                           SymbolInfo op1 = (SymbolInfo) ea1;
                           SymbolInfo op2 = (SymbolInfo) ea2;

                           if (!op1.getType().equals(op2.getType())) {
                                System.err.println("Error semantico, comparando dos cosas diferentes");
                           }

                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                       :}
                        | expresion_aritmetica NEQ expresion_aritmetica
                        {:
                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                        :}
                        | expresion_aritmetica LT expresion_aritmetica
                        {:
                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                        :}
                        | expresion_aritmetica LE expresion_aritmetica
                        {:
                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                        :}
                        | expresion_aritmetica GT expresion_aritmetica
                        {:
                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                        :}
                        | expresion_aritmetica GE expresion_aritmetica
                        {:
                            RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                        :}
                        | expresion_aritmetica:ea {: RESULT = ea; :} ;

expresion_aritmetica ::= expresion_aritmetica:ea1 PLUS expresion_aritmetica:ea2
                        {:
                            SymbolInfo op1 = (SymbolInfo) ea1;
                            SymbolInfo op2 = (SymbolInfo) ea2;
                            FunctionInfo currentTable = symbolTable.getCurrentScope();
                            ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                            RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                        :}
                       | expresion_aritmetica:ea1 MINUS expresion_aritmetica:ea2
                       {:
                            SymbolInfo op1 = (SymbolInfo) ea1;
                            SymbolInfo op2 = (SymbolInfo) ea2;
                            FunctionInfo currentTable = symbolTable.getCurrentScope();
                            ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                            RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                       :}
                       | expresion_aritmetica:ea1 TIMES expresion_aritmetica:ea2
                       {:
                           SymbolInfo op1 = (SymbolInfo) ea1;
                           SymbolInfo op2 = (SymbolInfo) ea2;
                           FunctionInfo currentTable = symbolTable.getCurrentScope();
                           ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                           RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                       :}
                       | expresion_aritmetica:ea1 DIV expresion_aritmetica:ea2
                       {:
                            SymbolInfo op1 = (SymbolInfo) ea1;
                            SymbolInfo op2 = (SymbolInfo) ea2;
                            FunctionInfo currentTable = symbolTable.getCurrentScope();
                            ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                            RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                       :}
                       | expresion_aritmetica:ea1 MOD expresion_aritmetica:ea2
                       {:
                            SymbolInfo op1 = (SymbolInfo) ea1;
                            SymbolInfo op2 = (SymbolInfo) ea2;
                            FunctionInfo currentTable = symbolTable.getCurrentScope();
                            ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                            RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                       :}
                       | expresion_aritmetica:ea1 POW expresion_aritmetica:ea2
                       {:
                            SymbolInfo op1 = (SymbolInfo) ea1;
                            SymbolInfo op2 = (SymbolInfo) ea2;
                            FunctionInfo currentTable = symbolTable.getCurrentScope();
                            ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                            RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                       :}
                       | OPEN_PAREN expresion_aritmetica:ea CLOSE_PAREN
                       {:
                            RESULT = ea;
                       :}
                       | literales:l {: RESULT = l; :}
                       | unary_operators:uo {: RESULT = uo; :}
                       | llamada_funcion:lf {: RESULT = lf; :}
                       | error SEMICOLON
                       | error CLOSE_PAREN
                       | IDENTIFIER:id
                       {:
                           TokenInfo token = (TokenInfo) id;
                           SymbolInfo variable = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);

                           FunctionInfo currentTable = symbolTable.getCurrentScope();

                           Variable.checkExistance(variable, currentTable);
                           RESULT = variable;
                       :};

// Sentencias
sentencias ::= sentencia | sentencias sentencia ;
sentencia ::= creacion | creacionAsignacion | estructuraControl | arreglo | print_stmt | read_stmt | asignar | IDENTIFIER SEMICOLON | llamada_funcion SEMICOLON | error SEMICOLON ;

asignar ::= IDENTIFIER:id EQ expresion:e SEMICOLON
{:
    TokenInfo token = (TokenInfo) id;
    SymbolInfo variable = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);
    SymbolInfo expressionResult = (SymbolInfo) e;
    FunctionInfo currentTable = symbolTable.getCurrentScope();

    // Verificar compatibilidad de tipos
    Variable.checkType(variable, expressionResult, currentTable);
:};

creacion ::= nombrar:n SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.getCurrentScope();

    Variable.checkRepeated(info, currentTable);

    boolean inserted = currentTable.insert(info.getName(), info);

    RESULT = null;
:};

creacionAsignacion ::= nombrar:n EQ expresion:e SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.getCurrentScope();
    SymbolInfo expressionResult = (SymbolInfo) e;

    Variable.checkRepeated(info, currentTable);

    boolean inserted = currentTable.insert(info.getName(), info);

    Variable.checkType(info, expressionResult, currentTable);

    RESULT = null;
:};



// Funciones
funciones ::= funcion | funciones funcion ;
funcion ::= encabezadoFuncion bloque ;

bloque ::= apertura_bloque sentencias cierre_bloque
         | apertura_bloque cierre_bloque | apertura_bloque error cierre_bloque ;

apertura_bloque ::= OPEN_BLOCK
    {:
        FunctionInfo currentFunction = symbolTable.getCurrentScope();
        if (currentFunction != null) {
            currentFunction.beginScope();
        } else {
            System.err.println("Error: No se puede abrir un bloque fuera de una función.");
        }
    :};

cierre_bloque ::= CLOSE_BLOCK
    {:
        FunctionInfo currentTable = symbolTable.getCurrentScope();
        if (currentTable != null) {
            currentTable.printScopes();
            currentTable.endScope();
        } else {
            System.err.println("Error: No se puede cerrar un bloque fuera de una función.");
        }
    :} ;


encabezadoFuncion ::= nombrar:i parametros:e
    {:
        SymbolInfo funcSymbol = (SymbolInfo) i;
        String funcName = funcSymbol.getName();
        String returnType = funcSymbol.getType();
        System.out.println("\n Función: '" + funcName + "' con tipo de retorno '" + returnType + "'");
        List<SymbolInfo> paramList = (List<SymbolInfo>) e;
        for (SymbolInfo param : paramList) {
            System.out.println("Parámetro: nombre = " + param.getName() + ", tipo = " + param.getType());
        }
        FunctionInfo fInfo = new FunctionInfo(funcName, returnType,0,0, paramList);

        // Insertar la función en la tabla de símbolos
        boolean inserted = symbolTable.pushFunction(fInfo);

        // Iniciar el primer scope de la función
        fInfo.beginScope();
    :};


parametros ::= OPEN_PAREN CLOSE_PAREN
    {:
    System.out.println("Sin parámetros");
    RESULT = new ArrayList<SymbolInfo>();
    :}
    | OPEN_PAREN parametroAux:p CLOSE_PAREN
     {:
        RESULT = p;
     :};

parametroAux ::= parametro:p
    {:
        List<SymbolInfo> lista = new ArrayList<SymbolInfo>();
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :}
    | parametroAux:pl  COMMA parametro:p
    {:
        List<SymbolInfo> lista = (List<SymbolInfo>) pl;
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :};


parametro ::= nombrar:n {: RESULT = n; :};

llamada_funcion ::= IDENTIFIER:id OPEN_PAREN argumentos:a CLOSE_PAREN
    {:
        TokenInfo token = (TokenInfo) id;

        String funcName = token.getValue();
        FunctionInfo function = symbolTable.lookupFunction(funcName);

        if (function != null) {

            SymbolInfo symbolFunc = new SymbolInfo(function.getName(), function.getType(), 0, 0);

            RESULT = symbolFunc;

        } else {
            System.err.println("Error semantico, la funcion: " + funcName + " no existe, linea: " + token.getLine() + " y columna: " + token.getColumn());
            RESULT = null;
        }
    :} ;

argumentos ::= /* vacio */ | expresion | argumentos COMMA expresion ;

// Estructuras de Control
estructuraControl ::= if_stmt | else_if_list | while_cicle | switch_stmt | for_cicle | return_stmt | break_stmt ;

if_stmt ::= IF OPEN_PAREN expresion CLOSE_PAREN bloque // If simple
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque ELSE bloque  // If con else al final
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list ; // If con uno o varios elif

else_if_list ::= ELSE IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list_opt ;
else_if_list_opt ::= /* vacío */ | else_if_list | ELSE bloque ;

while_cicle ::= WHILE OPEN_PAREN expresion CLOSE_PAREN bloque ;

break_stmt ::= BREAK SEMICOLON ;

// Ciclo For
for_cicle ::= FOR OPEN_PAREN condicion_for CLOSE_PAREN bloque ;
condicion_for ::= inicializacion_opt SEMICOLON condicion_opt SEMICOLON actualizacion_opt ;

inicializacion_opt ::= creacionAsignacion | expresion | /* vacío */ ;

condicion_opt ::= expresion | /* vacío */ ;

actualizacion_opt ::= expresion | /* vacío */ ;


// Switch-case
switch_stmt ::= SWITCH OPEN_PAREN expresion CLOSE_PAREN bloque_switch ;

bloque_switch ::= OPEN_BLOCK case_list default_stmt_opt CLOSE_BLOCK ;

case_list ::= case_stmt | case_list case_stmt ;

case_stmt ::= CASE literales_num COLON sentencias ;

default_stmt_opt ::= default_stmt | /* vacío */ ;

default_stmt ::= DEFAULT COLON sentencias ;

// Static Array
arreglo ::= tipos IDENTIFIER array_size SEMICOLON  // Declaración sin inicialización
          | tipos IDENTIFIER array_size EQ OPEN_BLOCK listaValores CLOSE_BLOCK SEMICOLON ;

array_size ::= OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET | OPEN_BRACKET IDENTIFIER CLOSE_BRACKET ;

// Lista de valores para inicialización
listaValores ::= listaValores COMMA literales | literales ;

// Unary Operators
unary_operators ::= negacion
                  | IDENTIFIER INCREMENT
                  | IDENTIFIER DECREMENT ;

negacion ::= MINUS literales_num ;

return_stmt ::= RETURN SEMICOLON | RETURN expresion SEMICOLON ;

// Print y Read

print_stmt ::= PRINT OPEN_PAREN lista_print CLOSE_PAREN SEMICOLON ;
lista_print ::= expresion | lista_print COMMA expresion ;

read_stmt ::= READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON ;

programa ::= conjuntoFunciones | error {: System.err.println("Error relacionado a la ausencia o mal estructura de la funcion main"); :} ;
conjuntoFunciones ::= funciones funcionMain | funcionMain ;
funcionMain ::= tipos MAIN bloque ;
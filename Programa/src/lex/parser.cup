package parser ;
import tables.SymbolTable;
import tables.SymbolInfo;
import tables.FunctionInfo;
import tables.TokenInfo;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java_cup.runtime.*;

//utiliza class Lexer que genera el lexer.jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:

action code {:
    /*CODIGO DE JAVA
    https://www.jflex.de/
    http://www2.cs.tum.edu/projects/cup/examples.php*/

    public void hola(){

                System.out.println("Hola");
    }

    public void adios(){

                System.out.println("Adiós");
    }
:}

parser code {:
    Lexer parser;
    SymbolTable symbolTable = new SymbolTable();

    // Constructor del parser
    @SuppressWarnings("deprecation")
    public parser(Lexer parser){
        this.parser = parser;
        this.symbolFactory = new DefaultSymbolFactory();

        // Inicializar el ámbito global
        FunctionInfo globalFunction = new FunctionInfo("global", "void",0,0, new ArrayList<>());
        if (!symbolTable.pushFunction(globalFunction)) {
            System.err.println("Error: Función global ya está definida.");
        }
        globalFunction.beginScope();
    }

    @Override
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error sintactico, linea: " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error sintactico: " + message);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        // Reportar el error fatal sin detener el programa
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error fatal sintactico " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error fatal de sintaxis: " + message);
        }
    }

    @Override
    public void unrecovered_syntax_error(Symbol info) {
        if (info.value != null) {
            System.err.println("Error no recuperable en la linea " + (info.left + 1) + ", columna " + (info.right + 1));
        }
    }
:}

init with {: :};

/* define how to connect to the scanner! */
scan with {: return parser.next_token(); :};


/* Terminales (tokens retornados por el scanner). */
terminal BOOLEAN, BREAK, IDENTIFIER, INTEGER, INTEGER_LITERAL, STRING, EQ, EQEQ, PLUS, STRING_LITERAL,
 FLOAT, CHAR, OPEN_BLOCK, CLOSE_BLOCK, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN,
 MINUS, TIMES, DIV, MOD, POW, INCREMENT, DECREMENT, NEQ, LT, LE, GT, GE, AND, OR, NOT, SEMICOLON,
 IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, RETURN, COLON, PRINT, READ, MAIN, COMMA, CHAR_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, TokenInfo;

// no terminales
non terminal programa, tipos, sentencias, sentencia, creacion, creacionAsignacion, nombrar,
 literales, funciones, funcion, bloque, encabezadoFuncion, parametros, parametroAux, parametro,
 estructuraControl, if_stmt, else_if_list, else_if_list_opt, while_cicle, switch_stmt, for_cicle, return_stmt, break_stmt, expresion,
 expresion_aritmetica, literales_num, unary_operators, negacion, case_list, arreglo, encontrar_error, encontrar_error_aux,
 listaValores, case_stmt, default_stmt, conjuntoFunciones, funcionMain, bloque_switch, default_stmt_opt, expresion_logica,
 expresion_comparacion, condicion_for, inicializacion_opt, condicion_opt, actualizacion_opt, print_stmt, lista_print, read_stmt,
 apertura_bloque, cierre_bloque, asignar, array_size;


// Precedencias

precedence left ELSE;

precedence left EQEQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left AND, OR;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left POW;

//produccion de inicio
start with programa;

// Errores
encontrar_error ::= error encontrar_error_aux ;
encontrar_error_aux ::= encontrar_error_aux error | /* vacio */ ;

// Generalidades
tipos ::= INTEGER {: RESULT = "int"; :}
       | STRING  {: RESULT = "string"; :}
       | CHAR    {: RESULT = "char"; :}
       | BOOLEAN {: RESULT = "boolean"; :}
       | FLOAT   {: RESULT = "float"; :}
       ;

literales ::= INTEGER_LITERAL:i
    {:
        RESULT = Integer.valueOf(i.toString());
    :}
  | STRING_LITERAL:s
    {:
        RESULT = s.toString();
    :}
  | CHAR_LITERAL:c
    {:
        RESULT = c.toString();
    :}
  | BOOLEAN_LITERAL:b
    {:
        RESULT = Boolean.valueOf(b.toString());
    :}
  | FLOAT_LITERAL:f
    {:
        RESULT = Float.valueOf(f.toString());
    :};

// Literales Numéricos
literales_num ::= INTEGER_LITERAL | FLOAT_LITERAL | CHAR_LITERAL ;

nombrar ::= tipos:t IDENTIFIER:id
{:
    // Obtener el tipo
    String tipo = (String) t;

    // Cast correcto de 'id' a TokenInfo
    TokenInfo token = (TokenInfo) id;

    // Obtener el nombre, línea y columna
    String nombre = token.getValue();
    int linea = token.getLine() + 1;
    int columna = token.getColumn() + 1;

    // Imprimir la información de declaración
    //System.out.println("Declaración de variable '" + nombre + "' de tipo '" + tipo + "' en línea " + linea + ", columna " + columna);

    // Crear el SymbolInfo con la información de posición
    RESULT = new SymbolInfo(nombre, tipo, linea, columna);
:};

// Expresiones
expresion ::= expresion_logica ;

expresion_logica ::= expresion_logica AND expresion_logica
                   | expresion_logica OR expresion_logica
                   | NOT expresion_logica
                   | expresion_comparacion ;

expresion_comparacion ::= expresion_aritmetica EQEQ expresion_aritmetica  // Comparacion ==
                        | expresion_aritmetica NEQ expresion_aritmetica  // Comparacion !=
                        | expresion_aritmetica LT expresion_aritmetica   // Menor que <
                        | expresion_aritmetica LE expresion_aritmetica   // Menor o igual que <=
                        | expresion_aritmetica GT expresion_aritmetica   // Mayor que >
                        | expresion_aritmetica GE expresion_aritmetica   // Mayor o igual que >=
                        | expresion_aritmetica ; // Sin comparación, pasa la aritmética

expresion_aritmetica ::= expresion_aritmetica PLUS expresion_aritmetica
                       | expresion_aritmetica MINUS expresion_aritmetica
                       | expresion_aritmetica TIMES expresion_aritmetica
                       | expresion_aritmetica DIV expresion_aritmetica
                       | expresion_aritmetica MOD expresion_aritmetica
                       | expresion_aritmetica POW expresion_aritmetica
                       | OPEN_PAREN expresion_aritmetica CLOSE_PAREN
                       | IDENTIFIER
                       | literales
                       | unary_operators
                       | funcion
                       | encontrar_error SEMICOLON
                       | encontrar_error CLOSE_PAREN ;

// Sentencias
sentencias ::= sentencia | sentencias sentencia ;
sentencia ::= creacion | creacionAsignacion | estructuraControl | arreglo | print_stmt | read_stmt | asignar | IDENTIFIER SEMICOLON | encontrar_error SEMICOLON ;

asignar ::= IDENTIFIER EQ expresion SEMICOLON ;

creacion ::= nombrar:n SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.getCurrentScope();
    boolean inserted = currentTable.insert(info.getName(), info);
    if (!inserted) {
        System.err.println("Error semántico: La variable '" + info.getName() + "' ya existe en este ámbito.");
    }
    RESULT = null; // 'creacion' no necesita un valor semántico
:};

creacionAsignacion ::= nombrar:n EQ expresion:e SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.getCurrentScope();
    boolean inserted = currentTable.insert(info.getName(), info);
    if (!inserted) {
        System.err.println("Error semántico: La variable '" + info.getName() + "' ya existe en este ámbito.");
    }
    RESULT = null; // 'creacionAsignacion' no necesita un valor semántico
:};



// Funciones
funciones ::= funcion | funciones funcion ;
funcion ::= encabezadoFuncion bloque
    {:
        symbolTable.popFunction();
    :};

bloque ::= apertura_bloque sentencias cierre_bloque
         | apertura_bloque cierre_bloque | apertura_bloque encontrar_error cierre_bloque ;

apertura_bloque ::= OPEN_BLOCK
    {:
        FunctionInfo currentFunction = symbolTable.getCurrentScope();
        if (currentFunction != null) {
            currentFunction.beginScope();
        } else {
            System.err.println("Error: No se puede abrir un bloque fuera de una función.");
        }
    :};

cierre_bloque ::= CLOSE_BLOCK
    {:
        FunctionInfo currentTable = symbolTable.getCurrentScope();
        if (currentTable != null) {
            currentTable.printScopes();
            currentTable.endScope();
        } else {
            System.err.println("Error: No se puede cerrar un bloque fuera de una función.");
        }
    :} ;


encabezadoFuncion ::= nombrar:i parametros:e
    {:
        SymbolInfo funcSymbol = (SymbolInfo) i;
        String funcName = funcSymbol.getName();
        String returnType = funcSymbol.getType();
        System.out.println("\n Función: '" + funcName + "' con tipo de retorno '" + returnType + "'");
        List<SymbolInfo> paramList = (List<SymbolInfo>) e;
        for (SymbolInfo param : paramList) {
            System.out.println("Parámetro: nombre = " + param.getName() + ", tipo = " + param.getType());
        }
        FunctionInfo fInfo = new FunctionInfo(funcName, returnType,0,0, paramList);

        // Insertar la función en la tabla de símbolos
        boolean inserted = symbolTable.pushFunction(fInfo);
        if (!inserted) {
            System.err.println("Error semántico: La función '" + funcName + "' ya existe en este ámbito.");
        }

        // Iniciar el primer scope de la función
        fInfo.beginScope();
    :};


parametros ::= OPEN_PAREN CLOSE_PAREN
    {:
    System.out.println("Sin parámetros");
    RESULT = new ArrayList<SymbolInfo>();
    :}
    | OPEN_PAREN parametroAux:p CLOSE_PAREN
     {:
        RESULT = p;
     :};

parametroAux ::= parametro:p
    {:
        List<SymbolInfo> lista = new ArrayList<SymbolInfo>();
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :}
    | parametroAux:pl  COMMA parametro:p
    {:
        List<SymbolInfo> lista = (List<SymbolInfo>) pl;
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :};


parametro ::= nombrar:n {: RESULT = n; :};

// Estructuras de Control
estructuraControl ::= if_stmt | else_if_list | while_cicle | switch_stmt | for_cicle | return_stmt | break_stmt ;

if_stmt ::= IF OPEN_PAREN expresion CLOSE_PAREN bloque // If simple
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque ELSE bloque  // If con else al final
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list ; // If con uno o varios elif

else_if_list ::= ELSE IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list_opt ;
else_if_list_opt ::= /* vacío */ | else_if_list | ELSE bloque ;

while_cicle ::= WHILE OPEN_PAREN expresion CLOSE_PAREN bloque ;

break_stmt ::= BREAK SEMICOLON ;

// Ciclo For
for_cicle ::= FOR OPEN_PAREN condicion_for CLOSE_PAREN bloque ;
condicion_for ::= inicializacion_opt SEMICOLON condicion_opt SEMICOLON actualizacion_opt ;

inicializacion_opt ::= creacionAsignacion | expresion | /* vacío */ ;

condicion_opt ::= expresion | /* vacío */ ;

actualizacion_opt ::= expresion | /* vacío */ ;


// Switch-case
switch_stmt ::= SWITCH OPEN_PAREN expresion CLOSE_PAREN bloque_switch ;

bloque_switch ::= OPEN_BLOCK case_list default_stmt_opt CLOSE_BLOCK ;

case_list ::= case_stmt | case_list case_stmt ;

case_stmt ::= CASE literales_num COLON sentencias ;

default_stmt_opt ::= default_stmt | /* vacío */ ;

default_stmt ::= DEFAULT COLON sentencias ;

// Static Array
arreglo ::= tipos IDENTIFIER array_size SEMICOLON  // Declaración sin inicialización
          | tipos IDENTIFIER array_size EQ OPEN_BLOCK listaValores CLOSE_BLOCK SEMICOLON ;

array_size ::= OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET | OPEN_BRACKET IDENTIFIER CLOSE_BRACKET ;

// Lista de valores para inicialización
listaValores ::= listaValores COMMA literales | literales ;

// Unary Operators
unary_operators ::= negacion
                  | IDENTIFIER INCREMENT
                  | IDENTIFIER DECREMENT ;

negacion ::= MINUS literales_num ;

return_stmt ::= RETURN SEMICOLON | RETURN expresion SEMICOLON ;

// Print y Read

print_stmt ::= PRINT OPEN_PAREN lista_print CLOSE_PAREN SEMICOLON ;
lista_print ::= expresion | lista_print COMMA expresion ;

read_stmt ::= READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON ;

programa ::= conjuntoFunciones | encontrar_error {: System.err.println("Error relacionado a la ausencia o mal estructura de la funcion main"); :} ;
conjuntoFunciones ::= funciones funcionMain | funcionMain ;
funcionMain ::= tipos MAIN bloque ;
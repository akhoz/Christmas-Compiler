package parser;
import java_cup.runtime.*;


//utiliza class Lexer que genera el lexer.jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:

action code {:
    /*CODIGO DE JAVA
    https://www.jflex.de/
    http://www2.cs.tum.edu/projects/cup/examples.php*/

    public void hola(){

                System.out.println("Hola");
    }

    public void adios(){

                System.out.println("Adiós");
    }
:}

parser code {:
    // Connect this parser to a scanner!
    Lexer parser;

    @SuppressWarnings("deprecation")
    public parser(Lexer parser){
        this.parser=parser;
        this.symbolFactory = new DefaultSymbolFactory();
    }

:}

init with {: :};

/* define how to connect to the scanner! */
scan with {: return parser.next_token(); :};

/* Terminales (tokens retornados por el scanner). */
terminal ABSTRACT, BOOLEAN, BREAK, IDENTIFIER, INTEGER, INTEGER_LITERAL, STRING, EQ, EQEQ, PLUS, STRING_LITERAL,
 FLOAT, CHAR, OPEN_BLOCK, CLOSE_BLOCK, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, ERROR,
 MINUS, TIMES, DIV, MOD, POW, INCREMENT, DECREMENT, NEQ, LT, LE, GT, GE, AND, OR, NOT, SEMICOLON,
 IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, RETURN, COLON, PRINT, READ, MAIN, COMMA, CHAR_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL;

// no terminales
non terminal programa, programaAux, tipos, sentencias, sentencia, creacion, creacionAsignacion, nombrar,
 literales, funciones, funcion, bloque, encabezadoFuncion, parametros, parametroAux, parametro,
 estructuraControl, if_stmt, else_if_list, else_if_list_opt, while_cicle, switch_stmt, for_cicle, return_stmt, break_stmt, expresion,
 expresion_aritmetica, termino, factor, literales_num, unary_operators, negacion, break_stmt_opt, case_list, arreglo,
 listaValores, case_stmt, default_stmt, conjuntoFunciones, funcionMain, bloque_switch, default_stmt_opt, expresion_logica,
 expresion_comparacion, condicion_for, inicializacion_opt, condicion_opt, actualizacion_opt, print_stmt, lista_print, read_stmt;

// Precedencias

precedence left ELSE;

precedence left EQEQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left AND, OR;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;

//produccion de inicio
start with programa;

// Generalidades
tipos ::= INTEGER | STRING | CHAR | BOOLEAN | FLOAT ;
literales ::= INTEGER_LITERAL | STRING_LITERAL | CHAR_LITERAL | BOOLEAN_LITERAL | FLOAT ;

// Literales Numéricos
literales_num ::= INTEGER_LITERAL
            | FLOAT_LITERAL ;

nombrar ::= tipos IDENTIFIER ;
// Expresiones
expresion ::= expresion_logica ;

expresion_logica ::= expresion_logica AND expresion_logica
                   | expresion_logica OR expresion_logica
                   | NOT expresion_logica
                   | expresion_comparacion ;

expresion_comparacion ::= expresion_aritmetica EQEQ expresion_aritmetica  // Comparacion ==
                        | expresion_aritmetica NEQ expresion_aritmetica  // Comparacion !=
                        | expresion_aritmetica LT expresion_aritmetica   // Menor que <
                        | expresion_aritmetica LE expresion_aritmetica   // Menor o igual que <=
                        | expresion_aritmetica GT expresion_aritmetica   // Mayor que >
                        | expresion_aritmetica GE expresion_aritmetica   // Mayor o igual que >=
                        | expresion_aritmetica ; // Sin comparación, pasa la aritmética

expresion_aritmetica ::= expresion_aritmetica PLUS expresion_aritmetica
                       | expresion_aritmetica MINUS expresion_aritmetica
                       | expresion_aritmetica TIMES expresion_aritmetica
                       | expresion_aritmetica DIV expresion_aritmetica
                       | expresion_aritmetica MOD expresion_aritmetica
                       | OPEN_PAREN expresion_aritmetica CLOSE_PAREN
                       | IDENTIFIER
                       | literales
                       | unary_operators ;

// Sentencias
sentencias ::= sentencia | sentencias sentencia ;
sentencia ::= creacion | creacionAsignacion | estructuraControl | arreglo | print_stmt | read_stmt ;

creacion ::= nombrar SEMICOLON ;
creacionAsignacion ::= nombrar EQ expresion SEMICOLON ;

// Funciones
funciones ::= funcion | funciones funcion ;
funcion ::= encabezadoFuncion bloque ;

bloque ::= OPEN_BLOCK sentencias CLOSE_BLOCK ;
encabezadoFuncion ::= nombrar parametros;

parametros ::= OPEN_PAREN CLOSE_PAREN | OPEN_PAREN parametroAux CLOSE_PAREN ;
parametroAux ::= parametro | parametroAux COMMA parametro ;
parametro ::= nombrar ;

// Estructuras de Control
estructuraControl ::= if_stmt | else_if_list | while_cicle | switch_stmt | for_cicle | return_stmt | break_stmt ;

if_stmt ::= IF OPEN_PAREN expresion CLOSE_PAREN bloque // If simple
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque ELSE bloque  // If con else al final
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list // If con uno o varios elif
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list ELSE bloque ; // If con uno o varios elif y un else al final

else_if_list ::= ELSE IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list_opt ;
else_if_list_opt ::= /* vacío */
                   | else_if_list ;


while_cicle ::= WHILE OPEN_PAREN expresion CLOSE_PAREN bloque ;

break_stmt ::= BREAK SEMICOLON ;

// Ciclo For
for_cicle ::= FOR OPEN_PAREN condicion_for CLOSE_PAREN bloque ;
condicion_for ::= inicializacion_opt SEMICOLON condicion_opt SEMICOLON actualizacion_opt ;

inicializacion_opt ::= creacionAsignacion | expresion | /* vacío */ ;

condicion_opt ::= expresion | /* vacío */ ;

actualizacion_opt ::= expresion | /* vacío */ ;


// Switch-case
switch_stmt ::= SWITCH OPEN_PAREN expresion CLOSE_PAREN bloque_switch ;

bloque_switch ::= OPEN_BLOCK case_list default_stmt_opt CLOSE_BLOCK ;

case_list ::= case_stmt | case_list case_stmt ;

case_stmt ::= CASE literales_num COLON sentencias ;

default_stmt_opt ::= default_stmt | /* vacío */ ;

default_stmt ::= DEFAULT COLON sentencias ;

// Static Array
arreglo ::= tipos OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET IDENTIFIER SEMICOLON  // Declaración sin inicialización
          | tipos OPEN_BRACKET INTEGER_LITERAL CLOSE_BRACKET IDENTIFIER EQ OPEN_BLOCK listaValores CLOSE_BLOCK SEMICOLON ;

// Lista de valores para inicialización
listaValores ::= listaValores COMMA literales | literales ;

// Unary Operators
unary_operators ::= negacion
                  | IDENTIFIER INCREMENT
                  | IDENTIFIER DECREMENT ;

negacion ::= MINUS literales_num ;

return_stmt ::= RETURN SEMICOLON | RETURN expresion SEMICOLON ;

// Print y Read

print_stmt ::= PRINT OPEN_PAREN lista_print CLOSE_PAREN SEMICOLON ;
lista_print ::= expresion | lista_print COMMA expresion ;

read_stmt ::= READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON ;

programa ::= conjuntoFunciones ;
conjuntoFunciones ::= funciones funcionMain ;
funcionMain ::= tipos MAIN bloque ;
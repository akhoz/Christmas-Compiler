package parser ;
import tables.SymbolTable;
import tables.SymbolInfo;
import tables.FunctionInfo;
import tables.TokenInfo;
import semanticalAnalysis.Variable;
import semanticalAnalysis.Function;
import semanticalAnalysis.ControlStructureOperations;
import destCodeGenerator.*;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java_cup.runtime.*;

//utiliza class Lexer que genera el lexer.jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:

action code {:
    /*CODIGO DE JAVA
    https://www.jflex.de/
    http://www2.cs.tum.edu/projects/cup/examples.php*/

    public void hola(){

                System.out.println("Hola");
    }

    public void adios(){

                System.out.println("Adiós");
    }
:}

parser code {:
    Lexer parser;
    SymbolTable symbolTable = new SymbolTable();
    CodeGenerator codeGenerator;
    String currentFunctionName = null; // Variable para rastrear la función actual
    int paramsQuantity = 0 ;
    String currentCalledFunction = null;
    SymbolInfo nullSymbol = new SymbolInfo("null", "null", 0, 0);

    // Constructor del parser
    @SuppressWarnings("deprecation")
    public parser(Lexer parser){
        this.parser = parser;
        this.codeGenerator = new CodeGenerator();

        FunctionInfo globalFunction = new FunctionInfo("global", "void",0,0, new ArrayList<>());
        if (!symbolTable.pushFunction(globalFunction)) {
            System.err.println("Error: Función global ya está definida.");
        }
        globalFunction.beginScope();

        this.symbolFactory = new DefaultSymbolFactory();
    }

    @Override
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error sintactico, linea: " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error sintactico: " + message);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        // Reportar el error fatal sin detener el programa
        if (info instanceof Symbol) {
            Symbol symbol = (Symbol) info;
            System.err.println("Error fatal sintactico " + (symbol.left + 1) + ", columna " + (symbol.right + 1) + ": " + symbol.value);
        } else {
            System.err.println("Error fatal de sintaxis: " + message);
        }
    }

    @Override
    public void unrecovered_syntax_error(Symbol info) {
        if (info.value != null) {
            System.err.println("Error no recuperable en la linea " + (info.left + 1) + ", columna " + (info.right + 1));
        }
    }
:}

init with {: :};

/* define how to connect to the scanner! */
scan with {: return parser.next_token(); :};


/* Terminales (tokens retornados por el scanner). */
terminal BOOLEAN, BREAK, IDENTIFIER, INTEGER, INTEGER_LITERAL, STRING, EQ, EQEQ, PLUS, STRING_LITERAL,
 FLOAT, CHAR, OPEN_BLOCK, CLOSE_BLOCK, OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN,
 MINUS, TIMES, DIV, MOD, POW, INCREMENT, DECREMENT, NEQ, LT, LE, GT, GE, AND, OR, NOT, SEMICOLON,
 IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, RETURN, COLON, PRINT, READ, MAIN, COMMA, CHAR_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, TokenInfo;

// no terminales
non terminal programa, tipos, sentencias, sentencia, creacion, creacionAsignacion, nombrar,
 literales, funciones, funcion, bloque, encabezadoFuncion, parametros, parametroAux, parametro,
 estructuraControl, if_stmt, else_if_list, else_if_list_opt, while_cicle, switch_stmt, for_cicle, return_stmt, break_stmt, expresion,
 expresion_aritmetica, literales_num, unary_operators, negacion, case_list, arreglo,
 listaValores, case_stmt, default_stmt, conjuntoFunciones, funcionMain, bloque_switch, default_stmt_opt, expresion_logica,
 expresion_comparacion, condicion_for, inicializacion_opt, condicion_opt, actualizacion_opt, print_stmt, lista_print, read_stmt,
 apertura_bloque, cierre_bloque, asignar, array_size, llamada_funcion, argumentos, nombrar_array, indice_array;


// Precedencias

precedence left ELSE;

precedence left EQEQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left AND, OR;

precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left POW;

//produccion de inicio
start with programa;

// Generalidades
tipos ::= INTEGER {: RESULT = "int"; :}
       | STRING  {: RESULT = "string"; :}
       | CHAR    {: RESULT = "char"; :}
       | BOOLEAN {: RESULT = "boolean"; :}
       | FLOAT   {: RESULT = "float"; :}
       ;
literales ::= INTEGER_LITERAL:i
{:
    TokenInfo token = (TokenInfo) i;
    int value = Integer.parseInt(token.getValue());
    SymbolInfo symbol = new SymbolInfo("int", "int", token.getLine() + 1, token.getColumn() + 1);
    symbol.setValue(value);
    RESULT = symbol;
:}
| STRING_LITERAL:s
{:
    TokenInfo token = (TokenInfo) s;
    String value = token.getValue(); // Usar el valor del token
    SymbolInfo<String> symbol = new SymbolInfo<>("string", "string", token.getLine() + 1, token.getColumn() + 1);
    symbol.setValue(value);
    RESULT = symbol;
:}
| CHAR_LITERAL:c
{:
    TokenInfo token = (TokenInfo) c;
    char value = token.getValue().charAt(0); // Obtener el primer carácter
    SymbolInfo<Character> symbol = new SymbolInfo<>("char", "char", token.getLine() + 1, token.getColumn() + 1);
    symbol.setValue(value);
    RESULT = symbol;
:}
| BOOLEAN_LITERAL:b
{:
    TokenInfo token = (TokenInfo) b;
    boolean value = Boolean.parseBoolean(token.getValue()); // Convertir el valor a booleano
    SymbolInfo<Boolean> symbol = new SymbolInfo<>("boolean", "boolean", token.getLine() + 1, token.getColumn() + 1);
    symbol.setValue(value);
    RESULT = symbol;
:}
| FLOAT_LITERAL:f
{:
    TokenInfo token = (TokenInfo) f;
    float value = Float.parseFloat(token.getValue()); // Convertir el valor a flotante
    SymbolInfo<Float> symbol = new SymbolInfo<>("float", "float", token.getLine() + 1, token.getColumn() + 1);
    symbol.setValue(value);
    RESULT = symbol;
:}
;

// Literales Numéricos
literales_num ::= INTEGER_LITERAL | FLOAT_LITERAL | CHAR_LITERAL ;

nombrar ::= tipos:t IDENTIFIER:id
{:
    // Obtener el tipo
    String tipo = (String) t;

    // Cast correcto de 'id' a TokenInfo
    TokenInfo token = (TokenInfo) id;

    // Obtener el nombre, línea y columna
    String nombre = token.getValue();
    int linea = token.getLine() + 1;
    int columna = token.getColumn() + 1;

    // Imprimir la información de declaración
    //System.out.println("Declaración de variable '" + nombre + "' de tipo '" + tipo + "' en línea " + linea + ", columna " + columna);

    // Crear el SymbolInfo con la información de posición
    RESULT = new SymbolInfo(nombre, tipo, linea, columna);
:};

// Expresiones
expresion ::= expresion_logica:el {: RESULT = el; :} ;

expresion_logica ::= expresion_logica AND expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | expresion_logica OR expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | NOT expresion_logica
                   {:
                       RESULT = new SymbolInfo("boolean", "boolean", 0, 0);
                   :}
                   | expresion_comparacion:ec
                   {:
                       RESULT = ec;
                   :};

expresion_comparacion ::= expresion_aritmetica:ea1 EQEQ expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                        | expresion_aritmetica:ea1 NEQ expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                        | expresion_aritmetica:ea1 LT expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                        | expresion_aritmetica:ea1 LE expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                        | expresion_aritmetica:ea1 GT expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                        | expresion_aritmetica:ea1 GE expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                        | expresion_aritmetica:ea {: RESULT = ea; :} ;

expresion_aritmetica ::= expresion_aritmetica:ea1 PLUS expresion_aritmetica:ea2
                        {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                        :}
                       | expresion_aritmetica:ea1 MINUS expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                       | expresion_aritmetica:ea1 TIMES expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                       | expresion_aritmetica:ea1 DIV expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                       | expresion_aritmetica:ea1 MOD expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                       | expresion_aritmetica:ea1 POW expresion_aritmetica:ea2
                       {:
                             SymbolInfo op1 = (SymbolInfo) ea1;
                             SymbolInfo op2 = (SymbolInfo) ea2;
                             FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                             ControlStructureOperations.checkOperandsType(op1, op2, currentTable);
                             if (op1 != null) {
                                RESULT = new SymbolInfo(op1.getType(), op1.getType(), op1.getLine(), op1.getColumn());
                             } else {
                                RESULT = nullSymbol;
                             }
                       :}
                       | OPEN_PAREN expresion_aritmetica:ea CLOSE_PAREN
                       {:
                            RESULT = ea;
                       :}
                       | literales:l {: RESULT = l; :}
                       | unary_operators:uo {: RESULT = uo; :}
                       | llamada_funcion:lf {: RESULT = lf; :}
                       | indice_array:ia {: RESULT = ia; :}
                       | error SEMICOLON
                       | error CLOSE_PAREN
                       | IDENTIFIER:id
                       {:
                           TokenInfo token = (TokenInfo) id;
                           SymbolInfo variable = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);

                           FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);

                           Variable.checkExistance(variable, currentTable);

                           SymbolInfo variableDeTabla = currentTable.lookup(variable.getName());

                           if (variableDeTabla != null && !variableDeTabla.getDeclared()) {
                                System.err.println("Error semantico: variable no inicializada: " + variable.getName() + ", linea: " + variable.getLine() + " columna: " + variable.getColumn());
                           }

                           RESULT = variable;
                       :};


// Sentencias
sentencias ::= sentencia | sentencias sentencia ;
sentencia ::= creacion | creacionAsignacion | estructuraControl | arreglo | print_stmt | read_stmt | asignar | IDENTIFIER SEMICOLON | llamada_funcion SEMICOLON | error SEMICOLON ;

asignar ::= IDENTIFIER:id EQ expresion:e SEMICOLON
{:
    TokenInfo token = (TokenInfo) id;
    SymbolInfo variable = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);
    SymbolInfo expressionResult = (SymbolInfo) e;
    FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);

    // Verificar compatibilidad de tipos
    Variable.checkType(variable, expressionResult, currentTable, symbolTable);

    codeGenerator.assignValueToIdentifier(variable.getName(), expressionResult);
    // Agreagar checkInitilized ACA !!!
:};

creacion ::= nombrar:n SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);

    Variable.checkRepeated(info, currentTable);

    boolean inserted = currentTable.insert(info.getName(), info);
    codeGenerator.addToFunctionScope(info.getName(), info.getType()); // Revisar
    codeGenerator.cleanRegisters("");
    RESULT = null;
:};

creacionAsignacion ::= nombrar:n EQ expresion:e SEMICOLON
{:
    SymbolInfo info = (SymbolInfo) n;
    FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
    SymbolInfo expressionResult = (SymbolInfo) e;

    Variable.checkRepeated(info, currentTable);
    info.setDeclared(true); // Marcar la variable como declarada

    boolean inserted = currentTable.insert(info.getName(), info);

    Variable.checkType(info, expressionResult, currentTable, symbolTable);

    // System.out.println("--------++_+_+_-" + symbolTable.functionScopes);
    codeGenerator.addToFunctionScope(info.getName(), info.getType()); // Revisar

    codeGenerator.assignValueToIdentifier(info.getName(), expressionResult);
    codeGenerator.cleanRegisters("");

    RESULT = null;
:};



// Funciones
funciones ::= funcion | funciones funcion ;
funcion ::= encabezadoFuncion bloque
    {:
        FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);

        if (!currentTable.retornoEncontrado) {
            System.err.println("Error semantico: no se encontró retorno de la función: " + currentTable.getName());
        }
        currentFunctionName = "global";
        codeGenerator.closeFunction();
    :};

bloque ::= apertura_bloque sentencias cierre_bloque
         | apertura_bloque cierre_bloque | apertura_bloque error cierre_bloque ;

apertura_bloque ::= OPEN_BLOCK
    {:
        FunctionInfo currentFunction = symbolTable.lookupFunction(currentFunctionName);
        if (currentFunction != null) {
            currentFunction.beginScope();
        } else {
            System.err.println("Error: No se puede abrir un bloque fuera de una función.");
        }
    :};

cierre_bloque ::= CLOSE_BLOCK
    {:
        FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
        if (currentTable != null) {
            currentTable.printScopes();
            currentTable.endScope();
        } else {
            System.err.println("Error: No se puede cerrar un bloque fuera de una función.");
        }
    :};



encabezadoFuncion ::= nombrar:i parametros:e
    {:
        SymbolInfo funcSymbol = (SymbolInfo) i;
        String funcName = funcSymbol.getName();
        String returnType = funcSymbol.getType();
        System.out.println("\n Función: '" + funcName + "' con tipo de retorno '" + returnType + "'");
        List<SymbolInfo> paramList = (List<SymbolInfo>) e;
        for (SymbolInfo param : paramList) {
            System.out.println("Parámetro: nombre = " + param.getName() + ", tipo = " + param.getType());
        }
        FunctionInfo fInfo = new FunctionInfo(funcName, returnType, 0, 0, paramList);

        // Insertar la función en la tabla de símbolos
        boolean inserted = symbolTable.pushFunction(fInfo);
        if (inserted) {
            System.out.println("encabezadoFuncion: Función '" + funcName + "' insertada correctamente en la tabla de símbolos.");
        } else {
            System.err.println("encabezadoFuncion: Error: Función '" + funcName + "' ya está definida.");
        }
        currentFunctionName = funcName;

        // Iniciar el primer scope de la función
        fInfo.beginScope();

        // Insertar los parámetros en el ámbito actual
        boolean paramsInserted = fInfo.insertParamList(paramList);
        if (paramsInserted) {
            System.out.println("encabezadoFuncion: Parámetros insertados correctamente en el ámbito de la función.");
        } else {
            System.err.println("encabezadoFuncion: Error al insertar parámetros en el ámbito de la función.");
        }

        codeGenerator.createFunction(funcName, paramList);

        RESULT = fInfo;  // Retorna el FunctionInfo creado

        // Imprimir todas las funciones después de la inserción
        symbolTable.printAllFunctions();
    :};




parametros ::= OPEN_PAREN CLOSE_PAREN
    {:
    System.out.println("Sin parámetros");
    RESULT = new ArrayList<SymbolInfo>();
    :}
    | OPEN_PAREN parametroAux:p CLOSE_PAREN
     {:
        RESULT = p;
     :};

parametroAux ::= parametro:p
    {:
        List<SymbolInfo> lista = new ArrayList<SymbolInfo>();
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :}
    | parametroAux:pl COMMA parametro:p
    {:
        List<SymbolInfo> lista = (List<SymbolInfo>) pl;
        lista.add((SymbolInfo)p);
        RESULT = lista;
    :};


parametro ::= nombrar:n {: RESULT = n; :} | nombrar_array:n {: RESULT = n; :} ;

llamada_funcion ::=
       IDENTIFIER:id
       {:
         TokenInfo token = (TokenInfo) id;
         String funcName = token.getValue();
         currentCalledFunction = funcName;
       :}

        OPEN_PAREN argumentos:a CLOSE_PAREN

      {:
        TokenInfo token = (TokenInfo) id;

        String funcName = token.getValue();
        currentCalledFunction = funcName;
        FunctionInfo function = symbolTable.lookupFunction(funcName);

        if (function != null) {

            SymbolInfo symbolFunc = new SymbolInfo(function.getName(), function.getType(), 0, 0);

            if (function.getParamCount() != paramsQuantity) {
                System.err.println("Error semantico, se le estan pasando una cantidad de parametros incorrecta a la funcion: " + function.getName() + ", cantidad de parametros esperada: "
                    + function.getParamCount() + " y se recibieron: " + paramsQuantity + ", en la linea: " + (token.getLine() + 1) + " y columna: " + (token.getColumn() + 1));
            }

            paramsQuantity = 0;

            RESULT = symbolFunc;

        } else {
            System.err.println("Error semantico, la funcion: " + funcName + " no existe, linea: " + (token.getLine() + 1) + " y columna: " + (token.getColumn() + 1));
            RESULT = null;
        }

    :} ;

argumentos ::=
        /* vacio */
        | expresion:e
            {:
                FunctionInfo currentScope  = symbolTable.lookupFunction(currentFunctionName);
                FunctionInfo function = symbolTable.lookupFunction(currentCalledFunction);
                if (function.getParamCount() > 0 && paramsQuantity < function.getParamCount()) {
                    SymbolInfo currentParam = function.getParams().get(paramsQuantity);
                    SymbolInfo currentArg = (SymbolInfo) e;
                    Function.checkParamsTypes(currentParam, currentArg, currentScope);
                } else {
                    System.out.println("ASKAKSKASKASKAKSAKSK" + function.getParamCount() + " " + paramsQuantity + " " + function.getName());
                }
                paramsQuantity++;
            :}
        | argumentos COMMA expresion:e
            {:
                FunctionInfo currentScope  = symbolTable.lookupFunction(currentFunctionName);
                FunctionInfo function = symbolTable.lookupFunction(currentCalledFunction);
                if (function.getParamCount() > 0 && paramsQuantity < function.getParamCount()) {
                    SymbolInfo currentParam = function.getParams().get(paramsQuantity);
                    SymbolInfo currentArg = (SymbolInfo) e;
                    Function.checkParamsTypes(currentParam, currentArg, currentScope);
                } else {
                    System.out.println("ASKAKSKASKASKAKSAKSK" + function.getParamCount() + " " + paramsQuantity + " " + function.getName());
                }
                paramsQuantity++;
            :};

// Estructuras de Control
estructuraControl ::= if_stmt | else_if_list | while_cicle | switch_stmt | for_cicle | return_stmt | break_stmt ;

if_stmt ::= IF OPEN_PAREN expresion CLOSE_PAREN bloque // If simple
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque ELSE bloque  // If con else al final
          | IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list ; // If con uno o varios elif

else_if_list ::= ELSE IF OPEN_PAREN expresion CLOSE_PAREN bloque else_if_list_opt ;
else_if_list_opt ::= /* vacío */ | else_if_list | ELSE bloque ;

while_cicle ::= WHILE OPEN_PAREN expresion CLOSE_PAREN bloque ;

break_stmt ::= BREAK SEMICOLON ;

// Ciclo For
for_cicle ::= FOR OPEN_PAREN condicion_for CLOSE_PAREN bloque ;
condicion_for ::= inicializacion_opt SEMICOLON condicion_opt SEMICOLON actualizacion_opt ;

inicializacion_opt ::= creacionAsignacion | expresion | /* vacío */ ;

condicion_opt ::= expresion | /* vacío */ ;

actualizacion_opt ::= expresion | /* vacío */ ;


// Switch-case
switch_stmt ::= SWITCH OPEN_PAREN expresion CLOSE_PAREN bloque_switch ;

bloque_switch ::= OPEN_BLOCK case_list default_stmt_opt CLOSE_BLOCK ;

case_list ::= case_stmt | case_list case_stmt ;

case_stmt ::= CASE literales:l COLON sentencias
    {:
         SymbolInfo literal = (SymbolInfo) l;
         if (literal != null) {
            if (!"int".equals(literal.getType())) {
                System.err.println("Error semantico, se está pasando algo que no es int al número de caso de un switch (" + literal.getType() + "), linea: " + literal.getLine() + " columna: " + literal.getColumn());
            } else {
                if (literal.getValue() instanceof Integer) {
                    int value = (int) literal.getValue();
                    if (value < 0) {
                        System.err.println("Error semantico, el número de caso debe ser positivo, se recibió: " + value + " linea: " + literal.getLine() + " columna: " + literal.getColumn());
                    }
                } else {
                    System.err.println("Error semantico, el valor del caso no es un entero válido. Línea: " + literal.getLine() + " columna: " + literal.getColumn());
                }
            }
         }
    :};

default_stmt_opt ::= default_stmt | /* vacío */ ;

default_stmt ::= DEFAULT COLON sentencias ;

// Static Array
arreglo ::=  nombrar_array SEMICOLON  // Declaración sin inicialización
          | nombrar_array EQ OPEN_BLOCK listaValores CLOSE_BLOCK SEMICOLON ;

nombrar_array ::= tipos:t IDENTIFIER:id array_size:as
    {:
         TokenInfo token = (TokenInfo) id;
          String tipo = (String) t;
         SymbolInfo array = new SymbolInfo(token.getValue(), tipo, token.getLine() + 1, token.getColumn() + 1);
         SymbolInfo expression = (SymbolInfo) as;
         FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
         Variable.checkRepeated(array, currentTable);
         boolean inserted = currentTable.insert(array.getName(), array);
         Variable.checkArraySize(array, expression, currentTable, symbolTable);
    :};

array_size ::= OPEN_BRACKET expresion:e CLOSE_BRACKET
    {:
        RESULT = e;
    :};

indice_array ::= IDENTIFIER array_size ;

// Lista de valores para inicialización
listaValores ::= listaValores COMMA literales | literales ;

// Unary Operators
unary_operators ::= negacion
                  | IDENTIFIER:id INCREMENT
                    {:
                        TokenInfo token = (TokenInfo) id;
                        SymbolInfo op = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);
                        FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                        ControlStructureOperations.checkUnaryOperandType(op, currentTable);
                        if (op != null) {
                            RESULT = new SymbolInfo(op.getType(), op.getType(), op.getLine(), op.getColumn());
                        } else {
                            RESULT = new SymbolInfo("null", "null", 0, 0);
                        }
                    :}
                  | IDENTIFIER:id DECREMENT
                    {:
                        TokenInfo token = (TokenInfo) id;
                        SymbolInfo op = new SymbolInfo(token.getValue(), null, token.getLine() + 1, token.getColumn() + 1);
                        FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                        ControlStructureOperations.checkUnaryOperandType(op, currentTable);
                        if (op != null) {
                            RESULT = new SymbolInfo(op.getType(), op.getType(), op.getLine(), op.getColumn());
                        } else {
                            RESULT = new SymbolInfo("null", "null", 0, 0);
                        }
                    :};

negacion ::= MINUS literales:l
    {:
        SymbolInfo literal = (SymbolInfo) l;
        ControlStructureOperations.checkNegationType(literal);
        RESULT = new SymbolInfo(literal.getType(), literal.getType(), literal.getLine(), literal.getColumn());
    :};

return_stmt ::= RETURN SEMICOLON
            | RETURN expresion:e SEMICOLON
            {:
                SymbolInfo retorno = (SymbolInfo) e;
                FunctionInfo currentTable = symbolTable.lookupFunction(currentFunctionName);
                Function.checkReturnType(retorno, currentTable);
                currentTable.retornoEncontrado = true ;
            :};

// Print y Read

print_stmt ::= PRINT OPEN_PAREN lista_print CLOSE_PAREN SEMICOLON ;
lista_print ::= expresion | lista_print COMMA expresion ;

read_stmt ::= READ OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON ;

programa ::= conjuntoFunciones {: codeGenerator.addFinalCode(); :}| error {: System.err.println("Error relacionado a la ausencia o mal estructura de la funcion main"); :} ;
conjuntoFunciones ::= funciones funcionMain | funcionMain ;
funcionMain ::= tipos:t MAIN bloque:c
    {:
        currentFunctionName = "global";
    :};

